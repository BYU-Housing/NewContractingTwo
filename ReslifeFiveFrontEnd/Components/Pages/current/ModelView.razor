@inject IGenService genService
@inject IJSRuntime JS
@inject ITimeZoneService timeZone
@inject ICsvService Csv
@inject ILogger<ManageUser> _logger
@typeparam T where T : class, new()







<div>
    <h1>@typeof(T).Name Manager</h1>



    <Grid TItem="T" DataProvider="TDataProvider"
          Class="table table-hovor table-bordered table-striped"
          AllowPaging="true"
          AllowSorting="true"
          AllowFiltering="true"
          PageSize="@(pageSize ?? 15)"
          Responsive="true"
          AllowSelection="true"
          AllowRowClick="true"
          OnRowDoubleClick="ViewItemModal"
          SelectionMode="GridSelectionMode.Multiple"
          SelectedItemsChanged="OnSelectedTItemsChanged">
        @foreach (var prop in typeof(T).GetProperties(BindingFlags.Public | BindingFlags.Instance)
        .Where(p => p.GetMethod != null // Has a getter
        && p.SetMethod != null // Has a setter
        && p.GetCustomAttribute<NotMappedAttribute>() == null))
        {

            var isForeignKey = IsForeignKeyProperty(prop);
            var isRelatedObject = IsRelatedObjectProperty(prop);

            if (isForeignKey && isRelatedObject)
            {
                var relatedProperty = typeof(T).GetProperty(prop.Name.Replace("Id", ""));

                if (relatedProperty != null)
                {
                    <GridColumn TItem="T" HeaderText="@relatedProperty.Name" PropertyName="@relatedProperty.Name" SortKeySelector="@(GetSortKeySelectorForRelatedObject(relatedProperty))">
                        @{
                            var relatedObject = context.GetType().GetProperty(relatedProperty.Name)?.GetValue(context);
                            var displayProperty = relatedObject?.GetType().GetProperty("Name")?.GetValue(relatedObject)
                            ?? relatedObject?.GetType().GetProperty("Id")?.GetValue(relatedObject);
                        }
                        @displayProperty
                    </GridColumn>
                   
                }
            }
            else
            {
            <GridColumn TItem="T" HeaderText="@prop.Name" PropertyName="@prop.Name" SortKeySelector=@(GetSortKeySelectorForProperty(prop.Name)) >
                @context.GetType().GetProperty(prop.Name)?.GetValue(context)
                
            </GridColumn>
            }
        }


        
    </Grid>


</div>
<Modal @ref="TItemModal">
    <BodyTemplate>
        @if(typeof(T).GetProperties().Any(x => x.Name == "Id"))
        {
            <label>Id:</label>
            <h5>@selectedObject.GetType().GetProperty("Id")?.GetValue(selectedObject)</h5>
            <br />
        }
        @foreach (var prop in typeof(T).GetProperties(BindingFlags.Public | BindingFlags.Instance)
        .Where(p => p.GetMethod != null // Has a getter
        && p.SetMethod != null // Has a setter
        && p.GetCustomAttribute<NotMappedAttribute>() == null // Exclude [NotMapped]
        && p.Name != "Id")) // Exclude properties named "Id"
        {
            <label>@prop.Name</label>
            @if (prop.PropertyType == typeof(string))
            {
                <input type="text" class="form-control" value="@GetValue(selectedObject,prop)" @oninput="e => SetValue(selectedObject, prop, e.Value?.ToString())" />
                <br />
            }
            else if(prop.PropertyType == typeof(int))
            {
                <input type="number" class="form-control"
                       value="@GetValue(selectedObject, prop)"
                @oninput="e => SetValue(selectedObject, prop, int.TryParse(e.Value?.ToString(), out var result) ? result : (int?)null)" />
                <br />
            }
            else if (prop.PropertyType == typeof(bool) || prop.PropertyType == typeof(bool?))
            {
                var isChecked = (bool?)(GetValue(selectedObject, prop) ?? false);
                <br />
                <Select  @onchange="@(e => SetValue(selectedObject, prop, e.Value?.ToString() == "true"))">
                    <option value="true">True</option>
                    <option value="false">False</option>
                </Select>

                <br />
            }
            else if (prop.PropertyType == typeof(DateTime) || prop.PropertyType == typeof(DateTime?))
            {
                var dateValue = (DateTime?)(GetValue(selectedObject, prop));

                <DateInput TValue="DateTime?"
                           Value="dateValue"
                           ValueExpression="() => dateValue"
                           ValueChanged="(value) => SetValue(selectedObject, prop, value)" />
                           <br />
            }


        }
    </BodyTemplate>
    <FooterTemplate>

    </FooterTemplate>
</Modal>
@code {
    #region instantiations
    [Parameter]
    public int? pageSize { get; set; }




    public Modal TItemModal = default!;
    public IEnumerable<T>? TItems;
    private HashSet<T> SelectedItems = new();
    private bool gridUpdate = false;
    private T selectedObject = new T();
    private TimeZoneInfo? _localTimeZone;


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        _localTimeZone = await timeZone.GetUserTimeZoneAsync();
    }

    #endregion

    #region GRID
    private async Task<GridDataProviderResult<T>> TDataProvider(GridDataProviderRequest<T> request)
    {
        if(TItems is null || gridUpdate == true)
        {
            TItems = genService.GetModel<T>();
            gridUpdate = false;
        }
        return await Task.FromResult(request.ApplyTo(TItems));
    }

    private Task OnSelectedTItemsChanged(HashSet<T> items)
    {
        SelectedItems = items is not null && items.Any() ? items : new();
        return Task.CompletedTask;
    }
    private Expression<Func<T, IComparable>> GetSortKeySelectorForProperty(string propertyName)
    {
        var property = typeof(T).GetProperty(propertyName);
        if (property == null)
        {
            throw new InvalidOperationException($"Property '{propertyName}' not found on type {typeof(T).Name}.");
        }

        // Build the lambda expression dynamically
        var parameter = Expression.Parameter(typeof(T), "item");
        var propertyAccess = Expression.Property(parameter, property);
        var convert = Expression.Convert(propertyAccess, typeof(IComparable));
        return Expression.Lambda<Func<T, IComparable>>(convert, parameter);
    }
    private Expression<Func<T, IComparable>> GetSortKeySelectorForRelatedObject(PropertyInfo property)
    {
        // Parameter for the lambda (e.g., "item =>")
        var parameter = Expression.Parameter(typeof(T), "item");

        // Access the related object (e.g., "item.Role")
        var relatedObject = Expression.Property(parameter, property);

        // Access the "Name" or "Id" property of the related object
        var relatedProperty = Expression.PropertyOrField(relatedObject, "Name"); // Fallback to "Id" if needed

        // Ensure the property is cast to IComparable
        var converted = Expression.Convert(relatedProperty, typeof(IComparable));

        // Build the final lambda expression
        return Expression.Lambda<Func<T, IComparable>>(converted, parameter);
    }
    private bool IsRelatedObjectProperty(PropertyInfo property)
    {
        return property.PropertyType.IsClass
            && property.PropertyType != typeof(string)
            && !property.PropertyType.IsValueType
            && !property.PropertyType.IsArray
            && !typeof(System.Collections.IEnumerable).IsAssignableFrom(property.PropertyType);
    }
    private bool IsForeignKeyProperty(PropertyInfo property)
    {
        var relatedPropertyName = property.Name.Replace("Id", "");
        return typeof(T).GetProperty(relatedPropertyName) != null;
    }


    private async Task ViewItemModal(GridRowEventArgs<T> args)
    {
        selectedObject = args.Item;
        await TItemModal.ShowAsync();
    }


    #endregion

    #region Modal

    private void SetValue(T selectedObject, PropertyInfo prop, object? value)
    {
        prop.SetValue(selectedObject, value);
    }
    private object? GetValue(T obj, PropertyInfo prop)
    {
        return prop.GetValue(obj);
    }

    private DateTime? GetDatePart(PropertyInfo prop)
    {
        var value = prop.GetValue(selectedObject) as DateTime?;
        return value?.Date;
    }

    private TimeSpan? GetTimePart(PropertyInfo prop)
    {
        var value = prop.GetValue(selectedObject) as DateTime?;
        return value?.TimeOfDay;
    }
    private async Task UpdateDateTimeProperty(PropertyInfo prop)
    {
        // Extract the current date and time parts
        var currentDate = GetDatePart(prop);
        var currentTime = GetTimePart(prop);

        if (currentDate.HasValue && currentTime.HasValue)
        {
            // Combine the date and time parts into a full DateTime object
            var combinedDateTime = currentDate.Value.Date + currentTime.Value;

            // Convert to UTC using the TimeZoneService
            var utcDateTime = await timeZone.ConvertLocalToUtcAsync(combinedDateTime);

            // Update the selected object's DateTime property
            prop.SetValue(selectedObject, utcDateTime);

            // Refresh the UI
            StateHasChanged();
        }
    }
    // private async Task UpdateDateTimeProperty(PropertyInfo prop)
    // {
        
    // }
    









    #endregion
























}
