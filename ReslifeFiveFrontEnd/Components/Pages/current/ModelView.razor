@inject IGenService genService
@inject IJSRuntime JS
@inject ITimeZoneService timeZone
@inject ICsvService Csv
@inject ILogger<ManageUser> _logger
@inject IJSRuntime JS
@typeparam T where T : class, new()







<div>
    <h1>@typeof(T).Name Manager</h1>

    @if(_localTimeZone?.DaylightName != null && _localTimeZone.DaylightName != string.Empty){<h4>All times shown in @_localTimeZone.DaylightName</h4>}

    @if(SelectedItems.Any())
    {
        <Button Color="ButtonColor.Danger" @onclick="DeleteSelectedItems">Delete Selected</Button>
    }

    <Grid @ref="TItemGrid"  TItem="T" DataProvider="TDataProvider"
          Class="table table-hovor table-bordered table-striped"
          AllowPaging="true"
          AllowSorting="true"
          AllowFiltering="true"
          PageSize="@(pageSize ?? 15)"
          Responsive="true"
          AllowSelection="true"
          AllowRowClick="true"
          OnRowDoubleClick="ViewItemModal"
          SelectionMode="GridSelectionMode.Multiple"
          SelectedItemsChanged="OnSelectedTItemsChanged">
        @foreach (var prop in typeof(T).GetProperties(BindingFlags.Public | BindingFlags.Instance)
        .Where(p => p.GetMethod != null // Has a getter
        && p.SetMethod != null // Has a setter
        && p.GetCustomAttribute<NotMappedAttribute>() == null))
        {

            var isForeignKey = IsForeignKeyProperty(prop);
            var isRelatedObject = IsRelatedObjectProperty(prop);

            if (isForeignKey && isRelatedObject)
            {
                var relatedProperty = typeof(T).GetProperty(prop.Name.Replace("Id", ""));

                if (relatedProperty != null)
                {
                    <GridColumn TItem="T" HeaderText="@relatedProperty.Name" PropertyName="@relatedProperty.Name" SortKeySelector="@(GetSortKeySelectorForRelatedObject(relatedProperty))">
                        @{
                            var relatedObject = context.GetType().GetProperty(relatedProperty.Name)?.GetValue(context);
                            var displayProperty = relatedObject?.GetType().GetProperty("Name")?.GetValue(relatedObject)
                            ?? relatedObject?.GetType().GetProperty("Id")?.GetValue(relatedObject);
                        }
                        @displayProperty
                    </GridColumn>
                   
                }
            }
            else
            {
            <GridColumn TItem="T" HeaderText="@prop.Name" PropertyName="@prop.Name" SortKeySelector=@(GetSortKeySelectorForProperty(prop.Name))>
                    @if ((prop.PropertyType == typeof(DateTime) || prop.PropertyType == typeof(DateTime?)) && _localTimeZone?.DaylightName != null && _localTimeZone?.DaylightName != string.Empty)
                    {
                        <span>@timeZone.DisplayLocalTimeFromUtc((DateTime?)context.GetType().GetProperty(prop.Name)?.GetValue(context))</span>
                    }
                    else
                    {
                        @context.GetType().GetProperty(prop.Name)?.GetValue(context)
                    }
            </GridColumn>
            }
        }


        
    </Grid>


</div>
<Modal @ref="TItemModal">
    <BodyTemplate>
        @if(typeof(T).GetProperties().Any(x => x.Name == "Id"))
        {
            <label>Id:</label>
            <h5>@selectedObject.GetType().GetProperty("Id")?.GetValue(selectedObject)</h5>
            <br />
        }
        @foreach (var prop in typeof(T).GetProperties(BindingFlags.Public | BindingFlags.Instance)
        .Where(p => 
        p.GetCustomAttribute<NotMappedAttribute>() == null 
        && !p.GetMethod.IsVirtual
        ))
        {
            <label>@prop.Name</label>
            @if (prop.PropertyType == typeof(string))
            {
                <input type="text" class="form-control" value="@GetValue(selectedObject,prop)" @oninput="e => SetValue(selectedObject, prop, e.Value?.ToString())" />
                <br />
            }
            else if(prop.PropertyType == typeof(int))
            {
                <input type="number" class="form-control"
                       value="@GetValue(selectedObject, prop)"
                @oninput="e => SetValue(selectedObject, prop, int.TryParse(e.Value?.ToString(), out var result) ? result : (int?)null)" />
                <br />
            }
            else if (prop.PropertyType == typeof(bool) || prop.PropertyType == typeof(bool?))
            {
                var isChecked = (bool?)(GetValue(selectedObject, prop) ?? false);
                <br />
                <Select value="@(prop.GetValue(selectedObject)?.ToString()?.ToLower())" @onchange="@(e => SetValue(selectedObject, prop, e.Value?.ToString() == "true"))">
                    <option value="true">True</option>
                    <option value="false">False</option>
                </Select>

                <br />
            }
            else if (prop.PropertyType == typeof(DateTime) || prop.PropertyType == typeof(DateTime?))
            {

                var date = timeZone.DisplayLocalTimeFromUtc((DateTime?)GetValue(selectedObject, prop));
                <br />
                <input type="datetime"
                       value="@(date ?? @DateTime.Now)"
                       @onchange="e => SetValue(selectedObject, prop, timeZone.ConvertLocalToUtc(DateTime.TryParse(e.Value?.ToString(), out var result) ? result : (DateTime?)null))" />

                <br />
                <br />
              
            }
        }
    </BodyTemplate>
    <FooterTemplate>
        <Button Color="ButtonColor.Primary" @onclick="() => UpsertItem(selectedObject)" >Save Changes</Button>
    </FooterTemplate>
</Modal>


@code {
    #region instantiations
    [Parameter]
    public int? pageSize { get; set; }



    private bool itemsSelected = false;
    public Modal TItemModal = default!;
    public IEnumerable<T>? TItems;
    private HashSet<T> SelectedItems = new();
    private bool gridUpdate = false;
    private T selectedObject = new T();
    private TimeZoneInfo? _localTimeZone;
    private Grid<T> TItemGrid = default!;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        _localTimeZone = await timeZone.GetUserTimeZoneAsync();
        StateHasChanged();
    }

    #endregion

    #region GRID
    private async Task<GridDataProviderResult<T>> TDataProvider(GridDataProviderRequest<T> request)
    {
        if(TItems is null || gridUpdate == true)
        {
            TItems = genService.GetModel<T>();
            gridUpdate = false;
        }
        return await Task.FromResult(request.ApplyTo(TItems));
    }





    private Task OnSelectedTItemsChanged(HashSet<T> items)
    {
        SelectedItems = items is not null && items.Any() ? items : new();
        return Task.CompletedTask;
    }
    private Expression<Func<T, IComparable>> GetSortKeySelectorForProperty(string propertyName)
    {
        var property = typeof(T).GetProperty(propertyName);
        if (property == null)
        {
            throw new InvalidOperationException($"Property '{propertyName}' not found on type {typeof(T).Name}.");
        }

        // Build the lambda expression dynamically
        var parameter = Expression.Parameter(typeof(T), "item");
        var propertyAccess = Expression.Property(parameter, property);
        var convert = Expression.Convert(propertyAccess, typeof(IComparable));
        return Expression.Lambda<Func<T, IComparable>>(convert, parameter);
    }
    private Expression<Func<T, IComparable>> GetSortKeySelectorForRelatedObject(PropertyInfo property)
    {
        // Parameter for the lambda (e.g., "item =>")
        var parameter = Expression.Parameter(typeof(T), "item");

        // Access the related object (e.g., "item.Role")
        var relatedObject = Expression.Property(parameter, property);

        // Access the "Name" or "Id" property of the related object
        var relatedProperty = Expression.PropertyOrField(relatedObject, "Name"); // Fallback to "Id" if needed

        // Ensure the property is cast to IComparable
        var converted = Expression.Convert(relatedProperty, typeof(IComparable));

        // Build the final lambda expression
        return Expression.Lambda<Func<T, IComparable>>(converted, parameter);
    }
    private bool IsRelatedObjectProperty(PropertyInfo property)
    {
        return property.PropertyType.IsClass
            && property.PropertyType != typeof(string)
            && !property.PropertyType.IsValueType
            && !property.PropertyType.IsArray
            && !typeof(System.Collections.IEnumerable).IsAssignableFrom(property.PropertyType);
    }
    private bool IsForeignKeyProperty(PropertyInfo property)
    {
        var relatedPropertyName = property.Name.Replace("Id", "");
        return typeof(T).GetProperty(relatedPropertyName) != null;
    }


    private async Task ViewItemModal(GridRowEventArgs<T> args)
    {
        selectedObject = args.Item;
        await TItemModal.ShowAsync();
    }

    private async Task DeleteSelectedItems()
    {
        foreach(var item in SelectedItems)
        {
            genService.Remove<T>(item);
            await genService.SaveChangesAsync();
            await TItemGrid.RefreshDataAsync();
        }
    }


    #endregion

    #region Modal

    private void SetValue(T selectedObject, PropertyInfo prop, object? value)
    {
        prop.SetValue(selectedObject, value);
    }
    private object? GetValue(T obj, PropertyInfo prop)
    {
        return prop.GetValue(obj);
    }

    




    private async Task UpsertItem(T item)
    {
        foreach (var prop in item.GetType().GetProperties()
                                  .Where(x => x.PropertyType == typeof(DateTime) ||
                                            x.PropertyType == typeof(DateTime?)))
        {
            // Get the current value of the DateTime property
            var value = prop.GetValue(item);

            if (value is DateTime dateTimeValue)
            {
                // Check if the DateTime value is not in UTC
                if (dateTimeValue.Kind != DateTimeKind.Utc)
                {
                    prop.SetValue(item, DateTime.SpecifyKind(dateTimeValue, DateTimeKind.Utc));
                }
            }

        }

        genService.Upsert<T>(item);
        await TItemModal.HideAsync();
    }


    #endregion


}
